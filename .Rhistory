geom_point(aes(V1,V2, col=cluster)) +
theme(legend.position = "none") +
ggtitle(paste0(k," clusters con distancia ",
metodos_distancias[i_d]," y metodo de agregacion ",
metodos_agregacion[i_a]))
}
clusters_jer(data_tsne, 1, 1, 12)
clusters_jer <- function(data, i_d, i_a, k){
d_i <- dist(data, method = metodos_distancias[i_d])
model_i <- hclust(d2, method=metodos_agregacion[i_a])
# creamos un vector vacio para almacenar los resultados
res <- tibble("h" = quantile(d_i, probs  = (1:100)/100), n = 0)
# recorremos los 100 percentiles y vamos rellenando el vector con la distancia intra cluster
for (i in 1:100){
groups <- cutree(model_i, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
res$dist_k <- abs(res$n - k)
h_k <- res$h[which(res$dist_k == min(res$dist_k))][1]
groups <- cutree(model_i, h = h_k)
data$cluster <- factor(groups)
ggplot(data) +
geom_point(aes(V1,V2, col=cluster)) +
theme(legend.position = "none") +
ggtitle(paste0(k," clusters con distancia ",
metodos_distancias[i_d],
"\n y metodo de agregacion ",
metodos_agregacion[i_a]))
}
clusters_jer <- function(data, i_d, i_a, k){
d_i <- dist(data, method = metodos_distancias[i_d])
model_i <- hclust(d2, method=metodos_agregacion[i_a])
res <- tibble("h" = quantile(d_i, probs  = (1:100)/100), n = 0)
for (i in 1:100){
groups <- cutree(model_i, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
# encontramos la distnacia que cumple la restriccion de clusters
res$dist_k <- abs(res$n - k)
h_k <- res$h[which(res$dist_k == min(res$dist_k))][1]
groups <- cutree(model_i, h = h_k)
data$cluster <- factor(groups)
ggplot(data) +
geom_point(aes(V1,V2, col=cluster)) +
theme(legend.position = "none") +
ggtitle(paste0(k," clusters con distancia ",
metodos_distancias[i_d],
"\n y metodo de agregacion ",
metodos_agregacion[i_a]))
}
clusters_jer(data_tsne, 1, 1, 12)
clusters_jer(data_tsne, 4, 1, 12)
clusters_jer(data_tsne, 2, 1, 12)
clusters_jer(data_tsne, 3, 1, 12)
clusters_jer(data_tsne, 3, 5, 12)
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 1, 3)
# cargo librerias
pacman::p_load(tidyverse, Rtsne, ggdendro)
set.seed(42)
# cargo la data y aplico los mismos tratamientos que en el caso de DBScan
data_tsne  <- read.csv("data/video_games_sales.csv") %>%
mutate(User_Score = as.numeric(User_Score)) %>%
filter(!(is.na(Critic_Score) | is.na(User_Score))) %>%
select(Critic_Score, User_Score, User_Count, Global_Sales) %>%
unique() %>%
Rtsne() %>%
.$Y %>%
as.data.frame()
# exploramos la data
data_tsne %>% summary()
ggplot(data_tsne) +
geom_point(aes(V1,V2))
# calculamos la distancia euclideana
d <- dist(data_tsne)
# analizo graficamente la distribucion de las distancias entre puntos
hist(d)
# hacemos un modelo jerarquico con distancia completa
model_complete <- hclust(d, method="complete")
# obtenemos una sintesis del modelo
summary(model_complete)
# usamos la funcion dentro de R base para graficar el dendrograma
plot(model_complete)
abline(h = 40, col="red")
# replicamos el grafico con ggplot
ggdendrogram(model_complete, theme_dendro = TRUE) +
geom_hline(yintercept = 40, col="red")
# analizamos el arbol si lo cortamos en h = 40
groups <- cutree(model_complete, h = 40)
groups %>% unique() %>% length()
# asignamos grupos a los datos creando una nueva variable
data_tsne$cluster_complete <- factor(groups)
# visualizamos los grupos resultantes
ggplot(data_tsne) +
geom_point(aes(V1,V2, col=cluster_complete)) +
theme(legend.position = "none")
# creamos un vector vacio para almacenar los resultados
res <- tibble("h" = quantile(d, probs  = (1:100)/100), n = 0)
# recorremos los 100 percentiles y vamos rellenando el vector con la distancia intra cluster
for (i in 1:100){
groups <- cutree(model_complete, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
# visualizamos el numero de grupos vs h
ggplot(res, aes(h, n)) +
geom_point()
metodos_distancias <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
metodos_agregacion <- c("complete", "average", "median", "centroid", "single",
"ward.D", "ward.D", "mcquitty")
d2 <- dist(data_tsne, method = metodos_distancias[1])
model2 <- hclust(d2, method=metodos_agregacion[1])
summary(model2)
clusters_jer <- function(data, i_d, i_a, k){
d_i <- dist(data, method = metodos_distancias[i_d])
model_i <- hclust(d2, method=metodos_agregacion[i_a])
res <- tibble("h" = quantile(d_i, probs  = (1:100)/100), n = 0)
for (i in 1:100){
groups <- cutree(model_i, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
# encontramos la minima distancia que cumple el nro de clusters
res$dist_k <- abs(res$n - k)
h_k <- res$h[which(res$dist_k == min(res$dist_k))][1]
groups <- cutree(model_i, h = h_k)
data$cluster <- factor(groups)
ggplot(data) +
geom_point(aes(V1,V2, col=cluster)) +
theme(legend.position = "none") +
ggtitle(paste0(k," clusters con distancia ",
metodos_distancias[i_d],
"\n y metodo de agregacion ",
metodos_agregacion[i_a]))
}
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 1, 3)
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 1, 13)
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 5, 13)
clusters_jer <- function(data, i_d, i_a, k){
d_i <- dist(data, method = metodos_distancias[i_d])
model_i <- hclust(d2, method=metodos_agregacion[i_a])
res <- tibble("h" = quantile(d_i, probs  = (1:100)/100), n = 0)
for (i in 1:100){
groups <- cutree(model_i, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
# encontramos la minima distancia que cumple el nro de clusters
res$dist_k <- abs(res$n - k)
h_k <- res$h[which(res$dist_k == min(res$dist_k))][1]
groups <- cutree(model_i, h = h_k)
data$cluster <- factor(groups)
ggplot(data) +
geom_point(aes(V1,V2, col=cluster)) +
theme(legend.position = "none") +
ggtitle(paste0(k," clusters con distancia ",
metodos_distancias[i_d],
"\n y método de agregación ",
metodos_agregacion[i_a]))
}
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 5, 13)
? kmeans
? dbscan
? hclust
# cargo librerias
pacman::p_load(tidyverse, Rtsne, ggdendro)
set.seed(42)
# cargo la data y aplico los mismos tratamientos que en el caso de DBScan
data_tsne  <- read.csv("data/video_games_sales.csv") %>%
mutate(User_Score = as.numeric(User_Score)) %>%
filter(!(is.na(Critic_Score) | is.na(User_Score))) %>%
select(Critic_Score, User_Score, User_Count, Global_Sales) %>%
unique() %>%
Rtsne() %>%
.$Y %>%
as.data.frame()
View(data_tsne)
# exploramos la data
data_tsne %>% summary()
ggplot(data_tsne) +
geom_point(aes(V1,V2))
# calculamos la distancia euclideana
d <- dist(data_tsne)
# analizo graficamente la distribucion de las distancias entre puntos
hist(d)
# obtenemos una sintesis del modelo
summary(model_complete)
# hacemos un modelo jerarquico con distancia completa
model_complete <- hclust(d, method="complete")
# obtenemos una sintesis del modelo
summary(model_complete)
? hclust
knitr::opts_chunk$set(echo = TRUE)
data <- cars
View(data)
modelo_clust <- hclust(dist(data), method = "complete")
plot(modelo_clust)
# usamos la funcion dentro de R base para graficar el dendrograma
plot(model_complete)
abline(h = 40, col="red")
# replicamos el grafico con ggplot
ggdendrogram(model_complete, theme_dendro = TRUE) +
geom_hline(yintercept = 40, col="red")
# analizamos el arbol si lo cortamos en h = 40
groups <- cutree(model_complete, h = 40)
groups %>% unique() %>% length()
# asignamos grupos a los datos creando una nueva variable
data_tsne$cluster_complete <- factor(groups)
View(data_tsne)
# visualizamos los grupos resultantes
ggplot(data_tsne) +
geom_point(aes(V1,V2, col=cluster_complete)) +
theme(legend.position = "none")
# creamos un vector vacio para almacenar los resultados
res <- tibble("h" = quantile(d, probs  = (1:100)/100), n = 0)
View(res)
# recorremos los 100 percentiles y vamos rellenando el vector con la distancia intra cluster
for (i in 1:100){
groups <- cutree(model_complete, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
# visualizamos el numero de grupos vs h
ggplot(res, aes(h, n)) +
geom_point()
? dist
d2 <- dist(data_tsne, method = metodos_distancias[1])
metodos_distancias <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
metodos_agregacion <- c("complete", "average", "median", "centroid", "single",
"ward.D", "ward.D", "mcquitty")
d2 <- dist(data_tsne, method = metodos_distancias[1])
model2 <- hclust(d2, method=metodos_agregacion[5])
summary(model2)
clusters_jer <- function(data, i_d, i_a, k){
d_i <- dist(data, method = metodos_distancias[i_d])
model_i <- hclust(d_i, method=metodos_agregacion[i_a])
res <- tibble("h" = quantile(d_i, probs  = (1:100)/100), n = 0)
for (i in 1:100){
groups <- cutree(model_i, h = res$h[i])
res$n[i] <- groups %>% unique() %>% length()
}
# encontramos la minima distancia que cumple el nro de clusters
res$dist_k <- abs(res$n - k)
h_k <- res$h[which(res$dist_k == min(res$dist_k))][1]
groups <- cutree(model_i, h = h_k)
data$cluster <- factor(groups)
ggplot(data) +
geom_point(aes(V1,V2, col=cluster)) +
theme(legend.position = "none") +
ggtitle(paste0(k," clusters con distancia ",
metodos_distancias[i_d],
"\n y método de agregación ",
metodos_agregacion[i_a]))
}
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 1, 13)
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 1, 5, 13)
# probamos la funcion con distintos valores de i_d, i_a, y k
clusters_jer(data_tsne, 2, 5, 13)
library(tidyverse)
data_escalada  <- read.csv("video_games_sales.csv") %>%
mutate(User_Score = as.numeric(User_Score)) %>%
filter(!(is.na(Critic_Score) | is.na(User_Score))) %>%
select(-Global_Sales) %>%
select(Critic_Score, User_Score) %>%
scale() %>%
as_tibble()
data_escalada  <- read.csv("data/video_games_sales.csv") %>%
mutate(User_Score = as.numeric(User_Score)) %>%
filter(!(is.na(Critic_Score) | is.na(User_Score))) %>%
select(-Global_Sales) %>%
select(Critic_Score, User_Score) %>%
scale() %>%
as_tibble()
data_escalada %>% summary()
library(mclust)
model_gmm <- Mclust(data_escalada)
model_gmm
summary(model_gmm, parameters = TRUE)
plot(model_gmm, what = "BIC")
ggplot(data_escalada) +
aes(x=Critic_Score, y=User_Score, color=factor(model_gmm$classification)) +
geom_point(alpha=0.5)
? Mclust
model_gmm <- Mclust(data_escalada, G=2)
ggplot(data_escalada) +
aes(x=Critic_Score, y=User_Score, color=factor(model_gmm$classification)) +
geom_point(alpha=0.5)
mclust.options("emModelNames")
model_gmm <- Mclust(data_escalada, G=2, modelNames = "EII")
summary(model_gmm, parameters = TRUE)
ggplot(data_escalada) +
aes(x=Critic_Score, y=User_Score, color=factor(model_gmm$classification)) +
geom_point(alpha=0.5)
model_gmm <- Mclust(data_escalada, G=13, modelNames = "EII")
ggplot(data_escalada) +
aes(x=Critic_Score, y=User_Score, color=factor(model_gmm$classification)) +
geom_point(alpha=0.5)
# cargo librerias
pacman::p_load(tidyverse, Rtsne, mclust, e1071)
set.seed(42)
# cargo la data y aplico los mismos tratamientos que en el caso de DBScan
data_tsne  <- read.csv("data/video_games_sales.csv") %>%
mutate(User_Score = as.numeric(User_Score)) %>%
filter(!(is.na(Critic_Score) | is.na(User_Score))) %>%
select(Critic_Score, User_Score, User_Count, Global_Sales) %>%
unique() %>%
Rtsne() %>%
.$Y %>%
as.data.frame()
# exploramos la data
data_tsne %>% summary()
ggplot(data_tsne) +
geom_point(aes(V1,V2))
model_gmm <- Mclust(data_escalada, G=13, modelNames = "EII")
ggplot(data_escalada) +
aes(x=Critic_Score, y=User_Score, color=factor(model_gmm$classification)) +
geom_point(alpha=0.5)
model_gmm <- Mclust(data_tsne, G=13, modelNames = "EII")
ggplot(data_tsne) +
geom_point(aes(V1,V2, , color=factor(model_gmm$classification)))
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(model_gmm$classification)))
mclust.options("emModelNames")
gmm_func <- function(data, k, model){
model_gmm <- Mclust(data, G=k, modelNames = model)
ggplot(data) +
geom_point(aes(V1,V2, color=factor(model_gmm$classification)))
}
gmm_func(data_tsne, 13, "VII")
gmm_func(data_tsne, 13, "EEI")
gmm_func <- function(data, k, model){
model_gmm <- Mclust(data, G=k, modelNames = model)
ggplot(data) +
geom_point(aes(V1,V2, color=factor(model_gmm$classification))) +
theme(legend.position = "none")
}
gmm_func(data_tsne, 13, "VEE")
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(model_gmm$classification)))+
theme(legend.position = "none")
model_eii <- Mclust(data_tsne, G=13, modelNames = "EII")
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(model_eii$classification)))+
theme(legend.position = "none")
model_eii$data
model_eii$n
model_eii
model_eii$hypvol
model_eii$uncertainty
aa <- model_eii$uncertainty
aa <- model_eii$z
View(aa)
aa <- model_eii$z %>% rowSums()
pmax(model_eii$z)
aa <- pmax(model_eii$z)
View(aa)
aa <- apply(model_eii$z,1,max)
aa <- apply(model_eii$z,1,function(x) which(x)==max(x)))
aa <- apply(model_eii$z,1,function(x) which(x)==max(x))
aa <- apply(model_eii$z,1, function(x) which(x==max(x)))
aa <- apply(model_eii$z,1, function(x) ifelse(max(x) > .7, which(x==max(x)),0))
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(fuzzis)))+
theme(legend.position = "none")
fuzzis <- apply(model_eii$z,1, function(x) ifelse(max(x) > .7, which(x==max(x)),0))
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(fuzzis)))+
theme(legend.position = "none")
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(fuzzis)))
fuzzis <- apply(model_eii$z,1, function(x) ifelse(max(x) > .5, which(x==max(x)),0))
ggplot(data_tsne) +
geom_point(aes(V1,V2, color=factor(fuzzis)))
ggplot(data_tsne[fuzzis != 0]) +
geom_point(aes(V1,V2, color=factor(fuzzis)))
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis)))
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0])))
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,])
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,], aes(V1,V2))
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,], aes(V1,V2), alpha = 0.5)
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,], aes(V1,V2), alpha = 0.3, size=0.5)
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,], aes(V1,V2), alpha = 0.3, size=0.5) +
theme(legend.position = "none")
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,], aes(V1,V2), alpha = 0.3, size=0.8) +
theme(legend.position = "none")
ggplot(data_tsne[fuzzis != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzzis != 0]))) +
geom_point(data=data_tsne[fuzzis == 0,], aes(V1,V2), alpha = 0.5, size=0.8) +
theme(legend.position = "none")
fuzz_eii <- apply(model_eii$z,1, function(x) ifelse(max(x) > .5, which(x==max(x)),0))
ggplot(data_tsne[fuzz_eii != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzz_eii != 0]))) +
geom_point(data=data_tsne[fuzz_eii == 0,], aes(V1,V2), alpha = 0.5, size=0.8) +
theme(legend.position = "none")
mclust.options("emModelNames")
gmm_func <- function(data, k, model, threshold=NULL){
model_gmm <- Mclust(data, G=k, modelNames = model)
if(is.null(threshold)){
fuzz <- model_gmm$classification
} else {
fuzz <- apply(model_gmm$z,1, function(x) ifelse(max(x) > threshold, which(x==max(x)),0))
}
ggplot(data[fuzz != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzzis[fuzz != 0]))) +
geom_point(data=data[fuzz == 0,], aes(V1,V2), alpha = 0.5, size=0.8) +
theme(legend.position = "none") +
ggtitle(paste0(round(nrow(data[fuzz == 0,])/nrow(data)*100,0),"% de los datos sin cluster"))
}
gmm_func(data_tsne, 13, "VEE")
gmm_func(data_tsne, 13, "VEE", 0.7)
gmm_func(data_tsne, 13, "EII", 0.7)
gmm_func(data_tsne, 13, "EII")
gmm_func <- function(data, k, model, threshold=NULL){
model_gmm <- Mclust(data, G=k, modelNames = model)
if(is.null(threshold)){
fuzz <- model_gmm$classification
} else {
fuzz <- apply(model_gmm$z,1, function(x) ifelse(max(x) > threshold, which(x==max(x)),0))
}
ggplot(data[fuzz != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzz[fuzz != 0]))) +
geom_point(data=data[fuzz == 0,], aes(V1,V2), alpha = 0.5, size=0.8) +
theme(legend.position = "none") +
ggtitle(paste0(round(nrow(data[fuzz == 0,])/nrow(data)*100,0),"% de los datos sin cluster"))
}
gmm_func(data_tsne, 13, "EII")
gmm_func(data_tsne, 13, "VEE")
gmm_func(data_tsne, 13, "VEE", 0.7)
summary(model_gmm, parameters = TRUE)
summary(model_eii, parameters = TRUE)
model_all <- Mclust(data_tsne)
plot(model_all, what = "BIC")
model_all <- Mclust(data_tsne, G=1:20)
plot(model_all, what = "BIC")
model_all
ggplot(data_tsne) +
aes(x=V1, y=V2, color=factor(model_all$classification)) +
geom_point(alpha=0.5)
modelo_c_means <- cmeans(data_tsne, 13, m=3)
modelo_c_means$membership %>% head()
ggplot(data_tsne, aes(V1, V2, color = factor(modelo_c_means$cluster))) +
geom_point(alpha = 0.3)
ggplot(data_tsne, aes(V1, V2, color = factor(modelo_c_means$cluster))) +
geom_point()
ggplot(data_tsne, aes(V1, V2, color = factor(modelo_c_means$cluster))) +
geom_point() +
theme(legend.position = "none")
cmeans_func <- function(data, k, m, threshold=NULL){
model_gmm <-  cmeans(data, k, m=m)
if(is.null(threshold)){
fuzz <- modelo_c_means$cluster
} else {
fuzz <- apply(modelo_c_means$membership,1, function(x) ifelse(max(x) > threshold, which(x==max(x)),0))
}
ggplot(data[fuzz != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzz[fuzz != 0]))) +
geom_point(data=data[fuzz == 0,], aes(V1,V2), alpha = 0.5, size=0.8) +
theme(legend.position = "none") +
ggtitle(paste0(round(nrow(data[fuzz == 0,])/nrow(data)*100,0),"% de los datos sin cluster"))
}
cmeans_func(data_tsne, 13, 3, 0.7)
cmeans_func(data_tsne, 13, 3, 0.5)
cmeans_func(data_tsne, 13, 2, 0.5)
cmeans_func(data_tsne, 13, 1.1, 0.5)
cmeans_func(data_tsne, 13, 1.1, 0.3)
cmeans_func(data_tsne, 13, 1.1, 0.1)
cmeans_func(data_tsne, 13, 1.1, 0.2)
cmeans_func(data_tsne, 13, 5, 0.2)
? cmeans
cmeans_func <- function(data, k, fuzzifier, threshold=NULL){
model_gmm <-  cmeans(data, k, m=fuzzifier)
if(is.null(threshold)){
fuzz <- modelo_c_means$cluster
} else {
fuzz <- apply(modelo_c_means$membership, 1, function(x) ifelse(max(x) > threshold, which(x==max(x)),0))
}
ggplot(data[fuzz != 0,]) +
geom_point(aes(V1,V2, color=factor(fuzz[fuzz != 0]))) +
geom_point(data=data[fuzz == 0,], aes(V1,V2), alpha = 0.5, size=0.8) +
theme(legend.position = "none") +
ggtitle(paste0(round(nrow(data[fuzz == 0,])/nrow(data)*100,0),"% de los datos sin cluster"))
}
cmeans_func(data_tsne, 13, 5, 0.2)
cmeans_func(data_tsne, 13, 1, 0.2)
cmeans_func(data_tsne, 13, 1)
cmeans_func(data_tsne, 13, 1.5)
cmeans_func(data_tsne, 13, 1.5, 0.7)
gmm_func(data_tsne, 13, "VEE", 0.7)
cmeans_func(data_tsne, 13, 1.5, 0.7)
FPC <- function(membresias){
matriz <- membresias%*%t(membresias) # producto matricial
FPC <- sum(matriz*diag(nrow(matriz)))/nrow(matriz)
return(FPC)
}
FPC(modelo_c_means$membership)
FPC(model_all$z)
